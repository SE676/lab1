#include <stdio.h>
double fabsl(double x)
{
    if (x >= 0) // Х больше или ровно 0?
        return x; // Да, возврат х
    else return x * (-1); // Нет, возврат х*(-1)
}
double calculate(double a)
{ //целевая функция 
    double S1 = 0, S2 = 0, n = 0, pi; //Ввод переменных: S1-верхняя оценка; S2-нижняя оценка; n-количество членов ряда Лейбница
    do
    {
        n++; // увеличить n на 1 (n-нечетное)
        S1 = S2 + 1 / (2 * n - 1); // посчитать верхнюю оценку
        n++; //увеличить n на 1 (n-четное)
        S2 = S1 - 1 / (2 * n - 1); //посчитать нижнюю оценку
    } while (fabsl(S1 - S2) >= a); //выполнять действие пока разность верхней и нижней оценок не менее чем ?точность вычислений?
    pi = 2 * (S1 + S2); //вычислить среднее значение числа пи
    return pi; // Вернуть вычисленное значение числа пи
}
int main()
{  //тестирующая функция
    double r = 0.1, p; // Ввод переменных: r-изменяющаяся точность; p-вычисленное значение числа пи
    double pi[6] = { 3.1578643578, 3.1417811372, 3.1415946416, 3.1415926735, 3.1415926537, 3.1415926535 }; // массив с размерностью 6
    int a = 0, b = 6, result; // Ввод переменных: a-индекс элемента массива; b-количество элементов массива; result - результат
    while (a < b)
    { // Выполнять действие пока не закончатся все элементы в массиве 
        p = calculate(r); // определенное вычисленное значение числа пи с определенной точностью
        if (fabsl(p - pi[a]) < r) // Разность вычисленного и эталонного значения меньше точности? 
            result = 0; // Да
        else result = 1; // Нет
        r /= 10; // Изменение точности 
        a++; // увеличить a на 1 
        if (result == 1) // Результат равен 1?
            break; // Выход
    }
    return result; //Вернуть результат
}